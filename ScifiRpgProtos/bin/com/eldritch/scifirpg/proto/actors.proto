syntax = "proto2";

import "com/eldritch/scifirpg/proto/attributes.proto";
import "com/eldritch/scifirpg/proto/prerequisites.proto";
import "com/eldritch/scifirpg/proto/outcomes.proto";

message Faction {
	message Relation {
		optional string faction_id = 1; // OPTIONAL: might change to int32
		optional int32 reaction = 2; // positive good, negative bad
	}

	required string name = 1;
	repeated Relation relation = 2;
}

message DialogueTree {
	// DialogueTree ends when the player reaches a Dialogue with no choices.
	// When the DialogueTree ends, the player is returned to the first valid greeting.
	message Dialogue {
		optional string dialogue_id = 5; // The unique ID for this Dialogue within this tree
		required string text = 1;
		repeated Prerequisite prereq = 2;
		repeated Choice choice = 3;
		repeated Outcome outcome = 4;
		required bool greeting = 6 [default = false];
	}

	// By storing successor pointers as strings, we allow for cycles
	message Choice {
		required string text = 1;
		required string successor_id = 2;
		// The prereqs for a given choice are determined by the successor prereqs
	}

	// We keep all Dialogue options as a list, then convert them to a map in memory so we
	// can traverse the DialogueTree via pointers in Choices.  Some Dialogues are marked
	// as greetings, and one of these will serve as the 'root' of the tree.
	//
	// Multiple greetings are possible depending on what prereqs are met.
	// Order matters as the first greeting to meet all prereqs will be chosen,
	// even if multiple options are satisfied.
	//
	// A DialogueTree exists in isolation, unique to a particular Actor.  No Dialogue is
	// shared in this design.
	repeated Dialogue dialogue = 1;
}

message Actor {
	enum Gender {
		MALE = 0;
		FEMALE = 1;
	}

	message Stat {
		required Attribute attribute = 1;
		required int32 level = 2;
		optional int32 xp = 3; // OPTIONAL: may make global XP, N/A for NPCs
	}

	message FactionStatus {
		optional string faction_id = 1; // OPTIONAL: might change to int32
		optional int32 reputation = 2;
		optional int32 rank = 3; // not sure how to use this just yet
	}

	message Item {
		optional string item_id = 1; // OPTIONAL: may change to int32
		required int32 count = 2;
	}

	message StagedAugmentation {
		// Every aug has a slot requirement R.  By staging an aug, you fill up
		// R slots in the actor's slot bank.  Augs can be staged multiple times.
		// For every stage, an aug grants one use.
		optional string aug_id = 1; // OPTIONAL: may change to int32
		required int32 remaining_uses = 2;
		required int32 stages = 3;
	}

	message ActorDialogue {
		optional string actor_id = 1;
		optional string dialogue_id = 2;
	}

	// Names for various dialogue scenarios
	optional string id = 22; // unique key
	required string first_name = 1;
	optional string last_name = 2;
	optional string alias = 3;

	// Static info
	optional Attribute primary = 4; // OPTIONAL: may change
	optional Attribute secondary = 5; // OPTIONAL: may change
	required Gender gender = 6;

	// Dynamic info
	required int32 health = 7; // remaining, max health is calculated
	required int32 level = 8;
	repeated Stat stat = 9;
	repeated FactionStatus faction_status = 10;
	repeated Item inventory_item = 11;
	repeated string equipped_item_id = 21; // NPC: if not specified, inferred from inventory
	repeated string known_aug_id = 15;
	repeated StagedAugmentation staged_augmentation = 16; // if not specified, inferred from known augs

	// NPC info, N/A for player
	optional int32 aggression = 17; // low reaction: high value likely to attack, negative likely to surrender
	optional DialogueTree dialogue = 18;

	// Player info, N/A for NPCs
	repeated string encounter_seen = 19;
	repeated ActorDialogue dialogue_seen = 20;
}
